计算机网络
===
* TCP问题  
    * 陈述三次握手  
      * 第一次：client向server发送请求报文，其中包含一个同步synchronization信号。client开始等候回复  
      * 第二次：server收到client的请求报文，返回一个应答报文，其中包含一个同步信号和一个应答报文  
      * 第三次：client收到server的应答报文，也向server发送一个应答报文段，并进入established状态，当server收到这个应答报文，也进入established状态，连接建立  
    * 为什么是三次不是两次  
      * 如果是两次的话，第一次client发送请求报文，遇到网络拥塞无法传送到server，客户端便开始超时重发，如果重发的报文到达server，server进入established状态，返回应答报文两方建立连接。当连接断开后，如果之前发的请求报文发送到了，由于只有两次握手，server就进入established状态等待接收数据。  
    * 陈述四次挥手  
      * 第一次：当A端想要断开连接，便停止发送数据，向B端发送一个释放请求  
      * 第二次：当B端收到释放请求，向A发送一个确认报文，B在收到这个报文后进入Fin_wait状态，等待A的Fin报文  
      * 第三次：当B发送完所有数据，准备释放时，向A发送一个Fin报文，说明已经完成所有作业  
      * 第四次：当A收到Fin报文后，进入Time_wait状态，并向B发送一个确认报文。当B收到确认报文后，便关闭连接。A会等待两个MSL时间长度，如果没有收到B的重发请求，说明B已经关闭，A便关闭连接断开。  
      * MSL：maxmium segment lifetime 一个tcp分段可以在互联网中存活的最大时间。  
      * 为什么MSL是两个：一去一回两个最大长度，用以确认报文发送成功  
    * TCP流量控制：滑动窗口，滑动窗口的大小表明接收方还有多大缓冲区来接收数据，由于有确认过程，可以提高`可靠性`，可以通过大小的变化来控制发送效率不要超过设别的负载,是`流控`的体现
      * 发送窗口和接收窗口的大小不同，发送窗口包含已发送未收到确认和接收端允许发送但还未发送两部分。当接收端接收成功并返回确认信息后，发送窗口的左边沿会向右边沿靠拢，并开始发送下一个片区  
      * 接收端通过报文中的win=123来告知现在的接收窗口有多大  
      * `protocol buffer`的作用:压缩率和解析速度比xml快很多，`当滑动窗口不断变小，说明发送效率过快，接收端无法处理，为什么用protocol buffer，因为他解析速率高，可以加快接收端的处理速度，从而防止滑动窗口不断变小。处理快了，确认也快，导致窗口右沿可以不断右移`
    * TCP和UDP的区别  
      * `TCP`是面向连接的，在传输数据前要先通过三次握手建立连接。`UDP`是非连接的，可以实现广播发送，要发送数据就从应用程序把数据传输到网上，接收端用队列将数据存好供应用程序使用  
      * `TCP`需要维护连接状态，系统资源需求高，速度慢。`UDP`不需要，速度快，结构简单  
      * `TCP`有确认，超时重传，滑动窗口等机制，可以保证数据传输正确率。`UDP`不去确认是否收到，也不重复发送，无法保证正确率  
      * `TCP`有序列号来保证数据顺序，如果缺失则重发，如果重复则抛弃。`UDP`不保证数据顺序  
      * `TCP`字节流传输形式，`UDP`数据报文段传输形式  
* OSI七层模型  
   * 应用层(HTTP)；表示层；会话层；传输层(TCP,UDP)；网络层；数据链路层；物理层  
* HTTP问题  
   * HTTPS和HTTP的区别
      * `HTTP`是明文传输，数据都是未加密的，安全性差  
      * `HTTP`响应速度比HTTPS快，因为HTTP只需要tcp三次握手，client和server交换3个包，而`HTTPS`还需要SSL握手的9个包
      * 用的是完全不同的连接方式，所以接口也不同，`HTTP`是80，`HTTPS`是443
      * `HTTPS`是建立在SSL之上的HTTP,所以比`HTTP`更耗费服务器资源
   * SSL握手
   * HTTPS工作原理
   

   
