java concepts
===
* JVM结构
  * 类加载器：在启动的时候和类运行的时候把class文件加载到JVM中
  * 执行引擎：负责执行class文件中的指令
  * 内存区：分为计数器，堆区，栈区，方法区，方法栈
  * 本地方法接口
* java的内存模型
  * 程序计数器
    * 由于java是使用线程轮流切换来获得cpu执行时间的，所以需要计数器来记录每个线程所执行到的位置，从而在切换后还可以恢复到之前执行的位置。
  * java栈
    * 当线程执行一个方法时，会创建一个栈帧，放到java栈中去，当方法执行完以后，把栈帧出栈。
  * 本地方法栈
  * 堆
    * 堆是用来存放对象和数组的，会由java垃圾处理机制进行内存的回收，是被所有线程共享的。
  * 方法区
    * 是用来存放每个类的信息，静态变量，常量，还有编译器编译后的代码，被所有线程共享。
* 程序的设计模式
  * 六大原则
  * 代理模式
  * 策略模式
  * 单例模式
  * 装饰模式：创建实体的抽象类，实体的实现子类，一个装饰的抽象类，装饰的具体实现子类。通过用装饰实体类来包裹实现子类，这样就可以在原有实体类基础上添加装饰类的方法。这样可以不用创造太多子类，但是层次会比较复杂。
  * 工厂模式：定义一个创建对象的接口，让子类来实现他的创建过程，然后用工厂类去调用这些生产的方法。这样用户想要某种类型的对象，只需要向工厂类提供参数就可以获得相应的结果，不需要去直到其实现过程。这样扩展性比较高，如果想要添加新的产品，只要扩展工厂类就可以了，但是类的数量会太多。
* raid:硬盘冗余阵列
  * raid0:不备份，速度快，利用率高，但是容易数据丢失
  * raid1:完全备份，保证安全性，但是利用率低
  * raid5:使用N-1块磁盘大小存储数据，用一个磁盘大小的硬盘存储奇偶校验信息，分别位于每一个磁盘上。当其中一个损坏时，利用其他磁盘的奇偶校验信息来进行恢复，使用异或操作
* JVM类加载过程：
  * 加载：把class文件转化为二进制字节流放到方法去里，然后在内存中创建一个接口
  * 链接：验证结构是不是正确，分配内存，解析把符号引用转化为直接引用
  * 初始化：
  * 执行
  * 卸载
* java String类：
  * String a = "abc", String b = "abc"(a equal b, a == b) 因为equal比的是值，==比的是地址，都是从常量池里取出abc，所以地址一样(如果常量池中有，就取abc,否则创建abc然后取)
  * String a = new String("abc") 这里地址就不一样了，因为新建了一个对象，所以a是在堆中创建了一个新的对象
  * String a = "ab", String b = a+"c" 这里值一样地址不同，因为这里是先用StringBuffer把"ab"和"c"合并成"abc" 然后再用toString(),所以新的变量在堆中。
* java final关键字:
  * final 可以用来修饰变量，方法，类
    * 如果修饰变量，那么这个变量的值要不在初始化中设定，要不在构造方法里设定，如果有多个构造方法，那么每一个构造方法中都得定义
    * 如果修饰方法，那么这个方法不可以被重写
    * 如果修饰类，那么这个类不可以被继承
* 包装类：
  * int->Integer double->Double
    * 变成一个对象，可以用于转换进制或者获取最大值最小值等属性
