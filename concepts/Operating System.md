操作系统
===
* 进程线程问题
  * 什么是进程
    * 进程是资源分配的基本单位，也是调度运行的基本单位。比如用户运行一个程序，系统建立一个进程，并给他分配资源如内存空间，磁盘空间，I/O设备等。之后把进程放入就绪队列，进程调度程序选中进程，为之分配cpu等资源，进程才开始真正运行。`进程是系统中并发执行的单位`
  * 什么是线程
    * 线程是进程中执行运算的最小单位，如果进程是操作系统上完成的任务，线程就是用于完成该任务的多个子任务
  * 多线程和多进程的区别
    * 多个`进程`之间的数据是分开的，需要通过IPC(进程间通信)来实现；多个`线程`由于共享进程的数据空间，所以共享简单
    * `进程`占用内存多，切换比较复杂，CPU利用率低；`线程`占用内存少，切换比较简单，CPU利用率高
    * `进程`创建销毁比较复杂，速度慢；`线程`创建销毁比较简单，速度快
    * `进程`之间有内存隔离，单个的进程出问题不会导致整个应用崩溃，便于调试；`线程`之间没有内存隔离，一个线程崩溃会导致整个应用退出
  * 进程间通信(IPC)
    * 管道：管道是单向的，数据只能向一个方向传递，所以要建立一去一回两个管道；只能用于父子进程和兄弟进程之间；
    * 信号量：用来控制多个进程对于共享资源的访问，类似于锁的功能，防止某进程在访问共享资源的同时，另一进程也访问该资源
    * 消息队列：queue,先进先出，放到pool里可以。
    * 共享内存
    * 套接字
  * 线程间通信
    * 同个进程内部的线程：由于他们共享该进程的内存，可以通过其中的`全局变量`来实现
    * 不同进程中的线程：参考进程间的通信
    * 线程间的通信方式(主要目的是线程同步)：用全局变量；用消息，在windows系统里每一个线程都可以拥有自己的消息队列，可以用消息来通信；`用事件？`
  * 什么时候用多线程，什么时候用多进程
    * 频繁销毁创建的用`线程`
    * 需要大量计算的用`线程`
    * 需要多台机器分布的用`进程`
  * 进程例子：执行多个操作，比如一个取数据，一个改数据，一个展示数据
  * 线程例子：爬虫中多个爬虫一起在pool的分配下爬数据
  * 僵尸进程，孤儿进程，守护进程：
    * 僵尸进程：父进程没有等待子进程继续执行，子进程结束后没有一个相应的wait()或者join()来处理他，就变成僵尸进程，得一直占用资源
    * 孤儿进程：父进程在子进程结束之前就结束了，子进程就变成了孤儿进程，会把init进程(1号进程)当成继父，来正常的结束
    * 守护进程：在后台执行的进程，比如垃圾处理进程。创建过程，fork再fork，第一次fork为了把他的父进程变成init，第二次fork使他不需要接受终端的控制。
* 锁机制：
  * 乐观锁悲观锁：乐观锁是默认其他线程不会修改数据，只在提交时候确认一下版本号，确认没有被操作过，所以适用于读多的情况；悲观锁是默认其他线程都会操作数据，所以每次操作数据的时候都会上锁，适用于写多的情况。
  * 死锁：
    * 什么是死锁：在加了锁的情况下，A任务等待一个锁释放，B任务等待一个锁释放，结果A等待的锁是B加上的，就会出现死锁
    * 防止死锁的方法：增加超时参数，等待超过多久就结束。使用银行家算法来分配资源，在分配资源前判断任务是否安全即是否可以满足任务的全部需求。
